use std::path::PathBuf;
use structopt::StructOpt;
use anyhow::{Result, Context};
use tokio::process::Command;

#[derive(StructOpt)]
pub enum TestCmd {
    /// Run full system tests (replaces full_system_test.ps1)
    #[structopt(name = "system")]
    System {
        #[structopt(long)]
        skip_build: bool,
        #[structopt(long)]
        skip_compliance: bool,
        #[structopt(long, default_value = "reports")]
        report_dir: PathBuf,
    },

    /// Create test templates (replaces create-test-template(s).ps1)
    #[structopt(name = "template")]
    Template {
        #[structopt(long)]
        module: String,
        #[structopt(long, default_value = "compliance")]
        test_level: String,
    },

    /// Consolidate test directories (replaces consolidate-tests.ps1)
    #[structopt(name = "consolidate")]
    Consolidate,
}

impl TestCmd {
    pub async fn run(&self) -> Result<()> {
        match self {
            TestCmd::System { skip_build, skip_compliance, report_dir } => {
                self.run_system_tests(*skip_build, *skip_compliance, report_dir).await
            }
            TestCmd::Template { module, test_level } => {
                self.create_test_template(module, test_level).await
            }
            TestCmd::Consolidate => {
                self.consolidate_tests().await
            }
        }
    }

    async fn run_system_tests(&self, skip_build: bool, skip_compliance: bool, report_dir: &PathBuf) -> Result<()> {
        // Create report directory
        tokio::fs::create_dir_all(report_dir).await
            .context("Failed to create report directory")?;

        // Check dependencies
        self.check_dependencies().await?;

        // Build system if not skipped
        if !skip_build {
            Command::new("cargo")
                .args(["build", "--release"])
                .status()
                .await
                .context("Build failed")?;
        }

        // Run tests
        self.run_test_suite("unit").await?;
        self.run_test_suite("integration").await?;
        self.run_test_suite("performance").await?;
        
        if !skip_compliance {
            self.run_compliance_tests(report_dir).await?;
        }

        Ok(())
    }

    async fn check_dependencies(&self) -> Result<()> {
        let deps = ["cargo", "rustc", "git"];
        for dep in deps {
            Command::new("which")
                .arg(dep)
                .status()
                .await
                .context(format!("Required command {} not found", dep))?;
        }
        Ok(())
    }

    async fn run_test_suite(&self, suite: &str) -> Result<()> {
        Command::new("cargo")
            .args(["test", &format!("--test"), suite])
            .status()
            .await
            .context(format!("{} tests failed", suite))?;
        Ok(())
    }

    async fn run_compliance_tests(&self, report_dir: &PathBuf) -> Result<()> {
        Command::new("cargo")
            .args([
                "run", "--bin", "compliance_check",
                "--release", "--",
                "--output-dir", report_dir.to_str().unwrap()
            ])
            .status()
            .await
            .context("Compliance check failed")?;
        Ok(())
    }

    async fn create_test_template(&self, module: &str, test_level: &str) -> Result<()> {
        let template_dir = PathBuf::from("tests");
        tokio::fs::create_dir_all(&template_dir).await?;

        let template = self.generate_test_template(module, test_level);
        let file_path = template_dir.join(format!("{}.test.clar", module));
        
        tokio::fs::write(&file_path, template).await
            .context("Failed to write test template")?;

        Ok(())
    }

    fn generate_test_template(&self, module: &str, test_level: &str) -> String {
        format!(
            r#";; Test template for {}
;; Generated by Anya DAO Test Framework
;; Test Level: {}

(use-trait dao-trait .dao-trait.dao-trait)
(use-trait bip-compliance .bip-compliance.bip-341-342-trait)

;; BIP Compliance Tests
(define-test test-{}-bip-compliance
    (let (
        (sig (unwrap! (contract-call? .bip-compliance generate-test-sig) (err u401)))
        (pubkey (unwrap! (contract-call? .bip-compliance get-test-pubkey) (err u402)))
    )
    (asserts! (contract-call? .{} verify-taproot-signature sig pubkey) (err u403))
    )
)

;; Basic functionality tests
(define-test test-{}-basic
    ;; Add test logic here
)
"#,
            module, test_level, module, module, module
        )
    }

    async fn consolidate_tests(&self) -> Result<()> {
        // Migration paths
        let migrations = vec![
            ("test/dao", "tests/modules/dao"),
            ("test/compliance", "tests/system/compliance"),
            ("test/performance", "tests/performance"),
        ];

        // Perform migrations
        for (src, dst) in migrations {
            if tokio::fs::metadata(src).await.is_ok() {
                tokio::fs::create_dir_all(dst).await?;
                Command::new("mv")
                    .args([src, dst])
                    .status()
                    .await
                    .context(format!("Failed to migrate {} to {}", src, dst))?;
            }
        }

        // Remove empty directories
        if tokio::fs::metadata("test").await.is_ok() {
            tokio::fs::remove_dir_all("test").await
                .context("Failed to remove old test directory")?;
        }

        Ok(())
    }
}