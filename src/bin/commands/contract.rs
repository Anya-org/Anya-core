use std::path::PathBuf;
use structopt::StructOpt;
use anyhow::{Result, Context};
use tokio::fs;
use serde::{Deserialize, Serialize};

#[derive(StructOpt)]
pub enum ContractCmd {
    /// Create contract templates (replaces create-contract-templates.ps1)
    #[structopt(name = "template")]
    Template {
        #[structopt(long)]
        name: String,
        #[structopt(long, default_value = "dao")]
        contract_type: String,
        #[structopt(long)]
        output_dir: Option<PathBuf>,
    },
}

#[derive(Serialize, Deserialize)]
struct ContractTemplate {
    name: String,
    contract_type: String,
    traits: Vec<String>,
    functions: Vec<String>,
}

impl ContractCmd {
    pub async fn run(&self) -> Result<()> {
        match self {
            ContractCmd::Template { name, contract_type, output_dir } => {
                self.create_contract_template(name, contract_type, output_dir.as_deref()).await
            }
        }
    }

    async fn create_contract_template(&self, name: &str, contract_type: &str, output_dir: Option<&Path>) -> Result<()> {
        let template = match contract_type {
            "dao" => self.generate_dao_template(name),
            "dlc" => self.generate_dlc_template(name),
            "rgb" => self.generate_rgb_template(name),
            _ => anyhow::bail!("Unsupported contract type: {}", contract_type),
        };

        // Determine output directory
        let contract_dir = if let Some(dir) = output_dir {
            dir.to_path_buf()
        } else {
            PathBuf::from("contracts").join(contract_type)
        };

        // Create directory if it doesn't exist
        fs::create_dir_all(&contract_dir).await?;

        // Write contract file
        let contract_path = contract_dir.join(format!("{}.clar", name));
        fs::write(&contract_path, template).await
            .context(format!("Failed to write contract template to {}", contract_path.display()))?;

        // Create test file
        let test_dir = PathBuf::from("tests").join("contracts").join(contract_type);
        fs::create_dir_all(&test_dir).await?;
        
        let test_template = self.generate_test_template(name, contract_type);
        let test_path = test_dir.join(format!("{}.test.ts", name));
        fs::write(&test_path, test_template).await
            .context(format!("Failed to write test template to {}", test_path.display()))?;

        println!("Created contract template at: {}", contract_path.display());
        println!("Created test template at: {}", test_path.display());

        Ok(())
    }

    fn generate_dao_template(&self, name: &str) -> String {
        format!(
            r#";; {}.clar
;; DAO contract template
;; Generated by Anya Core Tools

(use-trait dao-trait .dao-trait.dao-trait)
(use-trait bip-compliance .bip-compliance.bip-341-342-trait)

;; Constants
(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-not-found (err u101))

;; Data Variables
(define-data-var total-supply uint u0)
(define-map balances principal uint)
(define-map allowed ((spender principal) (owner principal)) uint)

;; Public Functions
(define-public (initialize (name (string-ascii 32)) (symbol (string-ascii 10)) (decimals uint))
    (begin
        (asserts! (is-eq tx-sender contract-owner) err-owner-only)
        (ok true)))

;; Read-only Functions
(define-read-only (get-balance (account principal))
    (default-to u0 (map-get? balances account)))

;; Internal Functions
(define-private (transfer-internal (from principal) (to principal) (amount uint))
    (let ((from-balance (get-balance from))
          (to-balance (get-balance to)))
        (begin
            (asserts! (>= from-balance amount) (err u1))
            (map-set balances from (- from-balance amount))
            (map-set balances to (+ to-balance amount))
            (ok true))))

;; BIP Compliance
(define-public (verify-taproot-signature (sig (buff 64)) (pubkey (buff 32)))
    (begin
        (try! (contract-call? .bip-compliance verify-taproot-sig sig pubkey))
        (ok true)))
"#,
            name
        )
    }

    fn generate_dlc_template(&self, name: &str) -> String {
        format!(
            r#";; {}.clar
;; DLC contract template
;; Generated by Anya Core Tools

(use-trait dlc-trait .dlc-trait.dlc-trait)
(use-trait oracle-trait .oracle-trait.oracle-trait)

;; Constants
(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-invalid-state (err u101))

;; Data Variables
(define-data-var contract-state (string-ascii 20) "initialized")
(define-map outcomes principal {amount: uint, prediction: (string-ascii 64)})

;; Public Functions
(define-public (create-dlc 
    (oracle principal)
    (amount uint)
    (prediction (string-ascii 64)))
    (begin
        (asserts! (is-valid-oracle oracle) (err u1))
        (map-set outcomes tx-sender {amount: amount, prediction: prediction})
        (ok true)))

;; Read-only Functions
(define-read-only (get-outcome (participant principal))
    (map-get? outcomes participant))

;; Oracle Integration
(define-private (is-valid-oracle (oracle principal))
    (contract-call? .oracle-registry is-registered oracle))
"#,
            name
        )
    }

    fn generate_rgb_template(&self, name: &str) -> String {
        format!(
            r#";; {}.clar
;; RGB contract template
;; Generated by Anya Core Tools

(use-trait rgb-trait .rgb-trait.rgb-trait)
(use-trait asset-trait .asset-trait.asset-trait)

;; Constants
(define-constant contract-owner tx-sender)
(define-constant err-owner-only (err u100))
(define-constant err-invalid-asset (err u101))

;; Data Variables
(define-data-var total-supply uint u0)
(define-map rgb-assets principal {id: (buff 32), amount: uint})

;; Public Functions
(define-public (issue-asset 
    (recipient principal)
    (asset-id (buff 32))
    (amount uint))
    (begin
        (asserts! (is-eq tx-sender contract-owner) err-owner-only)
        (map-set rgb-assets recipient {id: asset-id, amount: amount})
        (var-set total-supply (+ (var-get total-supply) amount))
        (ok true)))

;; Read-only Functions
(define-read-only (get-asset-details (owner principal))
    (map-get? rgb-assets owner))

;; Asset Validation
(define-private (is-valid-asset (asset-id (buff 32)))
    (contract-call? .rgb-registry validate-asset asset-id))
"#,
            name
        )
    }

    fn generate_test_template(&self, name: &str, contract_type: &str) -> String {
        format!(
            r#"import {{ Clarinet, Tx, Chain, Account, types }} from 'https://deno.land/x/clarinet@v0.14.0/index.ts';
import {{ assertEquals }} from 'https://deno.land/std@0.90.0/testing/asserts.ts';

Clarinet.test({{
    name: "{} contract test suite",
    async fn(chain: Chain, accounts: Map<string, Account>) {{
        let deployer = accounts.get('deployer')!;
        let wallet_1 = accounts.get('wallet_1')!;

        // Test initialization
        let block = chain.mineBlock([
            Tx.contractCall(
                "{}",
                "initialize",
                [
                    types.ascii("Test {}"),   // name
                    types.ascii("TEST"),      // symbol
                    types.uint(6)             // decimals
                ],
                deployer.address
            )
        ]);
        block.receipts[0].result.expectOk().expectBool(true);

        // Add more specific tests based on contract type
        {}
    }}
}});
"#,
            name,
            name,
            name,
            match contract_type {
                "dao" => r#"
        // Test DAO-specific functionality
        let block2 = chain.mineBlock([
            Tx.contractCall(
                name,
                "get-balance",
                [types.principal(deployer.address)],
                deployer.address
            )
        ]);
        block2.receipts[0].result.expectOk().expectUint(0);"#,
                
                "dlc" => r#"
        // Test DLC-specific functionality
        let block2 = chain.mineBlock([
            Tx.contractCall(
                name,
                "create-dlc",
                [
                    types.principal(wallet_1.address),
                    types.uint(100),
                    types.ascii("test-prediction")
                ],
                deployer.address
            )
        ]);
        block2.receipts[0].result.expectOk().expectBool(true);"#,
                
                "rgb" => r#"
        // Test RGB-specific functionality
        let block2 = chain.mineBlock([
            Tx.contractCall(
                name,
                "issue-asset",
                [
                    types.principal(wallet_1.address),
                    types.buff(Buffer.from("test-asset-id")),
                    types.uint(1000)
                ],
                deployer.address
            )
        ]);
        block2.receipts[0].result.expectOk().expectBool(true);"#,
                
                _ => ""
            }
        )
    }
}